

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Lachesis Consensus &mdash; Lachesis 0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="From Poset to Blockchain" href="blockchain.html" />
    <link rel="prev" title="Usage" href="usage.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Lachesis
          

          
          </a>

          
            
            
              <div class="version">
                0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Lachesis Consensus</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#common-knowledge">Common Knowledge</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gossip-about-gossip">Gossip About Gossip</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lamport-timestamps">Lamport Timestamps</a></li>
<li class="toctree-l2"><a class="reference internal" href="#two-phase-commit">Two-Phase Commit</a></li>
<li class="toctree-l2"><a class="reference internal" href="#virtual-voting">Virtual Voting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#blockchain">Blockchain</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="blockchain.html">From Poset to Blockchain</a></li>
<li class="toctree-l1"><a class="reference internal" href="fastsync.html">FastSync</a></li>
<li class="toctree-l1"><a class="reference internal" href="extracted-comments.html">Extracted Comments</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Lachesis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Lachesis Consensus</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/consensus.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="lachesis-consensus">
<span id="consensus"></span><h1>Lachesis Consensus<a class="headerlink" href="#lachesis-consensus" title="Permalink to this headline">¶</a></h1>
<p>Lachesis is based on our own interpretation of Poset, but also builds upon
other techniques that facilitate coordination within distributed systems. Here,
we give a high-level overview of the most important concepts that inspired the
development of Lachesis and how they all fit together. This document is also
intended for a non-technical audience.</p>
<div class="section" id="common-knowledge">
<h2>Common Knowledge<a class="headerlink" href="#common-knowledge" title="Permalink to this headline">¶</a></h2>
<p>Roughly speaking, attaining common knowledge within a group means “everyone
knows that everyone known that everyone knows…” to infinity. It is a necessary
and sometimes even sufficient condition for reaching agreement and for
coordinating actions. This connection was perhaps first drawn by David Lewis in
his <a class="reference external" href="https://www.princeton.edu/~harman/Courses/PHI534-2012-13/Nov26/lewis-convention1.pdf">work on conventions</a>,
which led to the original definition. It is a fascinating topic that goes far
beyond computer systems. We highly recommend the book
<a class="reference external" href="https://www.cs.rice.edu/~vardi/papers/book.pdf">Reasoning About Knowledge</a>
for a very thorough treatment of the subject.</p>
<p>To get an intuition about the link between common knowledge and agreement, we
can look at the well know ‘coordinated attack’ problem. Two generals and their
respective armies are posted on opposite sides of an enemy city perched on top
of a hill. They must decide to attack together, at the same time, or not at all.
Indeed, if one general attacks alone, he will lose the battle. The only means of
communication is a messenger on horseback (always at risk of being intercepted
by the enemy). How do they coordinate their attack?</p>
<p>One general, having made the decision to attack, could send a messenger to the
other general. Upon receiving that message, the second general knows that the
first general wants to attack, but he doesn’t know that the first general knows
that he received the message. So he sends an acknowledgment. Upon receiving the
acknowledgment, the first general, knows that the second general knows that he
wants to attack, but he doesn’t know that the second general knows that he
received the acknowledgment… There is always this element of doubt preventing
either general from committing to a decision. It quickly becomes apparent that
what is needed is common knowledge.</p>
<p>The dilemma is that pure common knowledge is not attainable in practical
situations; particularly in asynchronous message passing systems with unreliable
transports (like the two generals). Hence, we have to relax our requirements and
rely on approximations of common knowledge. In Lachesis, we drop the simultaneity
and allow participants to decide at different times.</p>
</div>
<div class="section" id="gossip-about-gossip">
<h2>Gossip About Gossip<a class="headerlink" href="#gossip-about-gossip" title="Permalink to this headline">¶</a></h2>
<p>One way to approximate common knowledge in this context is to use a
communication protocol where participants regularly tell each other everything
they know about what everyone else knows. These are usually referred to as Full
Information Protocols, aka ‘gossip about gossip’.</p>
<p>Members locally record the history of the gossip protocol in a directed acyclic
graph, a DAG, where each vertex represents a gossip event and the edges connect
a vertex to the immediately-preceding vertices. Roughly speaking, a member, say
Alice, will repeatedly choose another member at random, say Bob, and attempt to
learn what he knows that she doesn’t know. She will send him a sync request
saying ‘Hey, here is what I know; what do you know that I don’t know?’. Bob will
compute the difference and respond with a set of events that he knows and Alice
doesn’t yet know. Alice will insert these events in her DAG, and create a new
event to record this sync. The newly created event includes the hashes of her
last event, and Bob’s last event. Hence, the DAG is connected by a succession of
recursive cryptographic hashes; like a blockchain, but two-dimensional. Each
event contains the hashes of the events below it and is digitally signed by its
creator. So the entire graph of hashes is cryptographically secure.</p>
<img alt="_images/dag.png" src="_images/dag.png" />
<p>The communication graph is a very rich data structure from which we can extract
all sorts of information about the history of gossip, and also derive a
consistent ordering of the events, even in the presence of faulty participants.
But let’s take it step by step.</p>
</div>
<div class="section" id="lamport-timestamps">
<h2>Lamport Timestamps<a class="headerlink" href="#lamport-timestamps" title="Permalink to this headline">¶</a></h2>
<p>Leslie Lamport introduced a seminal paper in 1978, entitled <a class="reference external" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">“Time, Clocks, and
the Ordering of Events in a Distributed System”</a>.
In this paper he describes a distributed algorithm for extracting a consistent
total ordering of the events in an asynchronous message passing system, using a
concept of Logical Clocks.</p>
<p>The algorithm follows some simple rules:</p>
<ol class="arabic simple">
<li><p>A process increments its counter before each event in that process;</p></li>
<li><p>When a process sends a message, it includes its counter value with the
message;</p></li>
<li><p>On receiving a message, the counter of the recipient is updated, if
necessary, to the greater of its current counter and the timestamp in the
received message. The counter is then incremented by 1 before the message is
considered received.</p></li>
<li><p>Ties are broken using an arbitrary function (eg. sort by hash)</p></li>
</ol>
<img alt="_images/dag_lamport.png" src="_images/dag_lamport.png" />
<p>This is a distributed algorithm. Each process independently follows these rules,
and there is no central synchronizing process or central storage.
Synchronization is achieved because all processes order the commands according
to their timestamps, so each process uses the same sequence of commands. A
process can execute a command timestamped T when it has learned of all commands
issued by all other processes with timestamps less than or equal to T.</p>
<p>However, the resulting algorithm requires the active participation of all the
processes. A process must know all the commands issued by other processes, so
that the failure of a single process will make it impossible for any other
process to execute commands, thereby halting the system. Lachesis implements
Lamport Timestamps on top of the poset, but with added steps for Byzantine
Fault Tolerance.</p>
<p>This paper triggered a wave of research on BFT consensus algorithms. Some famous
solutions are Paxos, PBFT, and Tendermint. Ultimately most of them are
variations of a very well known paradigm in computer science: two-phase commit.</p>
</div>
<div class="section" id="two-phase-commit">
<h2>Two-Phase Commit<a class="headerlink" href="#two-phase-commit" title="Permalink to this headline">¶</a></h2>
<p>We are not necessarily aware of it, but we all solve the consensus problem in
real life situations on a daily basis. This is illustrated in the following
quote from a <a class="reference external" href="http://www.the-paper-trail.org/post/2008-11-27-consensus-protocols-two-phase-commit/">blog</a>:</p>
<p>“Simple solutions to the consensus problem seem obvious. Think about how you
would solve a real world consensus problem - perhaps trying to arrange a game of
bridge for four people with three friends. You’d call all your friends in turn
and suggest a game and a time. If that time is good for everybody you have to
ring round and confirm, but if someone can’t make it you need to call everybody
again and tell them that the game is off. You might at the same time suggest a
new day to play, which then kicks off another round of consensus.”</p>
<p>Most distributed consensus protocols are special adaptations of this concept.
There is a theoretical result that says one can’t attain BFT, in the same
conditions, with ⅓ of malicious participants. So, with the assumption that at
least ⅔ of participants are good, the usual solution resembles something like
this:</p>
<ol class="arabic simple">
<li><p>Someone proposes a value</p></li>
<li><p>Everyone votes on the proposal and broadcasts their vote</p></li>
<li><p>Every one confirms they have received ⅔ of votes for the same proposal, and
broadcasts this confirmation.</p></li>
<li><p>When a participant collects ⅔ of such confirmations, it commits the value.</p></li>
</ol>
<p>Usually, the solutions vary around who gets to propose the value - aka the
leader - and how this leader is elected or changed.</p>
</div>
<div class="section" id="virtual-voting">
<h2>Virtual Voting<a class="headerlink" href="#virtual-voting" title="Permalink to this headline">¶</a></h2>
<p>A similar algorithm can be run internally thanks to the communication graph by
using the concept of virtual voting. Instead of exchanging votes directly, we
compute what other participants would have voted, based on our knowledge of what
they know.</p>
<p>First, the Poset defines a concept of <em>Strongly Seeing</em>:</p>
<p>“If there are n members, then an event w can strongly see an event x, if w can
see more than 2n/3 events by different members, each of which can see x”.</p>
<img alt="_images/strongly_seeing.png" src="_images/strongly_seeing.png" />
<p><em>Strongly Seeing</em> is analogous to receiving votes from two thirds of
participants in the first phase of the two-phase commit.</p>
<p>Also, we do not need a leader to propose a value. Instead, participants compute
virtual cuts in the poset, called rounds, which allow processing events in
batches. This is also a distributed algorithm where all members end up with the
same rounds. Roughly speaking, starting at round 0, when we reach a point when
⅔ of members can strongly see the cut from the previous rounds, we start a new
round. When there is common knowledge about a round, attested by <em>Strongly
Seeing</em>, we can decide on the order of event below that cut. The details of the
algorithm are best described in the <a class="reference external" href="https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf">original poset whitepaper</a>.</p>
<img alt="_images/dag_rounds.png" src="_images/dag_rounds.png" />
<p>So this algorithm doesn’t need a leader. All participants run the algorithm
locally, process rounds at their own speed, and end up outputting the same
batches of ordered events. Lachesis takes these batches of events and projects
them onto a blockchain.</p>
</div>
<div class="section" id="blockchain">
<h2>Blockchain<a class="headerlink" href="#blockchain" title="Permalink to this headline">¶</a></h2>
<p>A blockchain is a one-dimensional data-structure made of cryptographically
chained blocks. It is convenient to map our two-dimensional poset onto a
blockchain because the blockchain is much easier to work with when it comes to
consuming and verifying the output of the consensus algorithm. The concatenation
of blocks, and the transactions they contain, is recursively secured by digital
signatures. A block that obtains enough signatures (&gt;1/3) can immediately be
considered valid, along with all the blocks that precede it, because it contains
a signed fingerprint of the list of blocks so far. The projection method is
described in <a class="reference internal" href="blockchain.html#blockchain"><span class="std std-ref">From Poset to Blockchain</span></a>.</p>
<img alt="_images/dag_bx.png" src="_images/dag_bx.png" />
<p>So the output of Lachesis is a sequence of blocks; the interface between the app
and Lachesis is a blockchain interface. This makes it convenient for developers to
plug into Lachesis, and provides a base for building light-clients and cross-chain
communication protocols. We believe that the p2p internet is moving towards a
landscape of interconnected blockchains, the so called internet of blockchains,
an Lachesis is built with this in mind.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="blockchain.html" class="btn btn-neutral float-right" title="From Poset to Blockchain" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="usage.html" class="btn btn-neutral float-left" title="Usage" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Mosaic Networks

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>